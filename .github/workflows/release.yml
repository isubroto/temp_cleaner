name: Release WPF App with MSI

on:
  push:
    branches:
      - main
    tags:
      - "v*.*.*"
  workflow_dispatch:

permissions:
  contents: write
  actions: read  # Required for SignPath

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  project: ./TempCleaner.csproj
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GITHUB_OWNER: ${{ github.repository_owner }}
  GITHUB_REPO: ${{ github.event.repository.name }}

jobs:
  build:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: windows-latest
    name: Build WPF App and MSI

    outputs:
      version: ${{ steps.versions.outputs.safe }}
      full_version: ${{ steps.versions.outputs.full }}
      is_prerelease: ${{ contains(steps.gitversion.outputs.FullSemVer, '-') }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.x"

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0.11.0
        with:
          versionSpec: "5.x"

      - name: Determine Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v0.11.0

      - name: Compute versions
        id: versions
        shell: pwsh
        run: |
          $full = '${{ steps.gitversion.outputs.FullSemVer }}'
          $safe = $full -replace '\+', '.'
          Add-Content -Path $env:GITHUB_OUTPUT -Value "full=$full"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "safe=$safe"

      - name: Update .csproj Version
        shell: pwsh
        run: |
          $projFile = Get-Item $env:project
          $version = '${{ steps.versions.outputs.safe }}'
          $versionTag = "<Version>$version</Version>"
          $content = Get-Content $projFile.FullName -Raw
          if ($content -notmatch '<Version>.*?</Version>') {
            $content = $content -replace '</PropertyGroup>', "$versionTag`n</PropertyGroup>"
          } else {
            $content = $content -replace '<Version>.*?</Version>', $versionTag
          }
          Set-Content $projFile.FullName $content -Encoding UTF8

      - name: Restore Dependencies
        shell: pwsh
        run: dotnet restore ${{ env.project }} -r win-x64

      - name: Build WPF App
        shell: pwsh
        run: dotnet build ${{ env.project }} -c Release --no-restore

      - name: Publish WPF App
        shell: pwsh
        run: |
          dotnet publish ${{ env.project }} -c Release -r win-x64 `
            --self-contained true `
            -p:PublishSingleFile=true `
            -p:IncludeNativeLibrariesForSelfExtract=true `
            --no-build

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri https://github.com/wixtoolset/wix/releases/download/v6.0.0/wix-cli-x64.msi -OutFile wix6.msi
          Start-Process wix6.msi -ArgumentList "/quiet" -Wait
          Remove-Item wix6.msi

      - name: Generate Files.wxs
        shell: pwsh
        run: |
          & "C:\Program Files\WiX Toolset v6.0\bin\x64\heat.exe" dir "bin\Release\net8.0-windows\win-x64" `
            -cg AppFiles -dr INSTALLFOLDER -srd -gg -sreg -scom `
            -var var.SourceDir -out Installer\Files.wxs `
            -t Installer\TransformExcludePublish.xsl

      - name: Build MSI Installer
        working-directory: Installer
        shell: pwsh
        run: |
          $safeVersion = '${{ steps.versions.outputs.safe }}'
          & "C:\Program Files\WiX Toolset v6.0\bin\wix.exe" build Product.wxs Files.wxs `
            -arch x64 `
            -define ProductVersion=$safeVersion `
            -define SourceDir="..\bin\Release\net8.0-windows\win-x64" `
            -out "../publish/DeepCleaner-$safeVersion.msi"

      # Upload unsigned artifacts for signing
      - name: Upload Unsigned MSI for Signing
        uses: actions/upload-artifact@v4
        with:
          name: unsigned-msi
          path: publish/DeepCleaner-*.msi
          if-no-files-found: error

      - name: Upload Unsigned EXE for Signing
        uses: actions/upload-artifact@v4
        with:
          name: unsigned-exe
          path: bin/Release/net8.0-windows/win-x64/publish/*.exe
          if-no-files-found: error

      - name: Commit .csproj version change
        shell: pwsh
        run: |
          git config user.name "Subroto Saha"
          git config user.email "isubrotosaha@gmail.com"
          git add $env:project
          if (git diff --cached --quiet) {
            Write-Host "No changes to commit"
          } else {
            git commit -m "üîñ Bump version to ${{ steps.versions.outputs.safe }}"
            git push origin HEAD
          }

  # ==========================================
  # SIGNING JOB - Uses SignPath.io (Free OSS)
  # ==========================================
  sign:
    needs: build
    runs-on: ubuntu-latest
    name: Sign with SignPath
    # Only sign stable releases
    if: ${{ !contains(needs.build.outputs.full_version, '-') }}

    steps:
      - name: Download Unsigned MSI
        uses: actions/download-artifact@v4
        with:
          name: unsigned-msi
          path: unsigned/

      - name: Download Unsigned EXE
        uses: actions/download-artifact@v4
        with:
          name: unsigned-exe
          path: unsigned/

      # Create a zip for SignPath (it signs all files inside)
      - name: Create signing package
        run: |
          cd unsigned
          zip -r ../signing-package.zip .

      - name: Submit to SignPath
        uses: signpath/github-action-submit-signing-request@v1
        id: signpath
        with:
          api-token: '${{ secrets.SIGNPATH_API_TOKEN }}'
          organization-id: '<YOUR-ORG-ID>'           # Get from SignPath
          project-slug: 'DeepCleaner'                 # Your project name
          signing-policy-slug: 'release-signing'      # Usually this
          artifact-configuration-slug: 'default'      # Usually this
          input-artifact-path: 'signing-package.zip'
          output-artifact-path: 'signed-package.zip'
          wait-for-completion: true
          wait-for-completion-timeout-in-seconds: 600

      - name: Extract Signed Files
        run: |
          mkdir -p signed
          unzip signed-package.zip -d signed/

      - name: Upload Signed MSI
        uses: actions/upload-artifact@v4
        with:
          name: signed-msi
          path: signed/*.msi

      - name: Upload Signed EXE
        uses: actions/upload-artifact@v4
        with:
          name: signed-exe
          path: signed/*.exe

  # ==========================================
  # RELEASE JOB
  # ==========================================
  release:
    needs: [build, sign]
    # Run if sign succeeded, OR if it was skipped (prerelease)
    if: always() && needs.build.result == 'success'
    runs-on: windows-latest
    name: Create Release

    steps:
      # Download signed artifacts if available, otherwise unsigned
      - name: Download Signed MSI
        if: needs.sign.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: signed-msi
          path: release/

      - name: Download Signed EXE
        if: needs.sign.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: signed-exe
          path: release/

      - name: Download Unsigned MSI (fallback)
        if: needs.sign.result != 'success'
        uses: actions/download-artifact@v4
        with:
          name: unsigned-msi
          path: release/

      - name: Download Unsigned EXE (fallback)
        if: needs.sign.result != 'success'
        uses: actions/download-artifact@v4
        with:
          name: unsigned-exe
          path: release/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: "DeepCleaner v${{ needs.build.outputs.version }}"
          tag_name: v${{ needs.build.outputs.version }}
          body: |
            ## üßπ DeepCleaner v${{ needs.build.outputs.version }}

            ### üì¶ What's Included
            - ‚úÖ **Signed MSI Installer** - Trusted by Windows
            - ‚úÖ **Signed Portable Executable**

            ### üöÄ Installation
            
            #### Option 1: WinGet (Recommended)
            ```powershell
            winget install SubrotoSaha.DeepCleaner
            ```

            #### Option 2: MSI Installer
            Download `DeepCleaner-${{ needs.build.outputs.version }}.msi` and run it.

            #### Option 3: Portable
            Download `DeepCleaner.exe` and run directly.

            ### üìù Notes
            Report issues: https://github.com/${{ github.repository }}/issues
          files: |
            release/*.exe
            release/*.msi
          draft: false
          prerelease: ${{ needs.build.outputs.is_prerelease == 'true' }}
          generate_release_notes: true

  # ==========================================
  # WINGET SUBMISSION
  # ==========================================
  winget:
    needs: [build, release]
    if: ${{ !contains(needs.build.outputs.full_version, '-') }}
    runs-on: windows-latest
    name: Submit to WinGet

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Signed MSI
        uses: actions/download-artifact@v4
        with:
          name: signed-msi
          path: release/

      - name: Create WinGet Manifests
        shell: pwsh
        run: |
          $version = '${{ needs.build.outputs.version }}'
          $repo = "${{ github.repository }}"
          $repoUrl = "https://github.com/$repo"
          
          $msiName = "DeepCleaner-$version.msi"
          $msiPath = "release\$msiName"
          $msiUrl = "$repoUrl/releases/download/v$version/$msiName"
          
          $hash = (Get-FileHash -Path $msiPath -Algorithm SHA256).Hash
          
          function Get-MsiProperty {
            param([string]$Path, [string]$Property)
            $installer = New-Object -ComObject WindowsInstaller.Installer
            $database = $installer.GetType().InvokeMember("OpenDatabase","InvokeMethod",$null,$installer,@($Path,0))
            $view = $database.OpenView("SELECT Value FROM Property WHERE Property = '$Property'")
            $view.Execute()
            $record = $view.Fetch()
            $value = if ($record) { $record.StringData(1) } else { $null }
            $view.Close()
            return $value
          }
          
          $productCode = Get-MsiProperty -Path $msiPath -Property "ProductCode"
          
          New-Item -ItemType Directory -Force -Path "winget" | Out-Null
          
          @"
          PackageIdentifier: SubrotoSaha.DeepCleaner
          PackageVersion: $version
          DefaultLocale: en-US
          ManifestType: version
          ManifestVersion: 1.6.0
          "@ | Set-Content "winget/SubrotoSaha.DeepCleaner.yaml" -Encoding UTF8
          
          @"
          PackageIdentifier: SubrotoSaha.DeepCleaner
          PackageVersion: $version
          PackageLocale: en-US
          Publisher: Subroto Saha
          PublisherUrl: $repoUrl
          PublisherSupportUrl: $repoUrl/issues
          Author: Subroto Saha
          PackageName: DeepCleaner
          PackageUrl: $repoUrl
          License: MIT
          LicenseUrl: $repoUrl/blob/main/LICENSE
          Copyright: Copyright (c) 2025 Subroto Saha
          ShortDescription: A powerful Windows temporary files cleaner.
          Description: DeepCleaner helps clean temporary files, system cache, and free up disk space.
          Moniker: deepcleaner
          Tags:
            - cleaner
            - temp-files
            - disk-cleanup
            - windows
          ManifestType: defaultLocale
          ManifestVersion: 1.6.0
          "@ | Set-Content "winget/SubrotoSaha.DeepCleaner.locale.en-US.yaml" -Encoding UTF8
          
          @"
          PackageIdentifier: SubrotoSaha.DeepCleaner
          PackageVersion: $version
          Platform:
            - Windows.Desktop
          MinimumOSVersion: 10.0.0.0
          InstallModes:
            - interactive
            - silent
            - silentWithProgress
          UpgradeBehavior: install
          Installers:
            - Architecture: x64
              InstallerType: msi
              InstallerUrl: $msiUrl
              InstallerSha256: $hash
              ProductCode: '$productCode'
              Scope: machine
              InstallerSwitches:
                Silent: /qn /norestart
                SilentWithProgress: /qb! /norestart
          ManifestType: installer
          ManifestVersion: 1.6.0
          "@ | Set-Content "winget/SubrotoSaha.DeepCleaner.installer.yaml" -Encoding UTF8
          
          Write-Host "‚úÖ Manifests created"
          Write-Host "SHA256: $hash"
          Write-Host "ProductCode: $productCode"

      - name: Download wingetcreate
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri "https://aka.ms/wingetcreate/latest" -OutFile wingetcreate.exe

      - name: Submit to WinGet
        env:
          WINGET_TOKEN: ${{ secrets.WINGET_TOKEN }}
        shell: pwsh
        run: |
          .\wingetcreate.exe submit `
            --prtitle "Add SubrotoSaha.DeepCleaner v${{ needs.build.outputs.version }}" `
            --token "$env:WINGET_TOKEN" `
            winget